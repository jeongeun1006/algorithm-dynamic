# algorithm-dynamic

## 1로 만들기

+ 설명
1. x가 5로 나누어 떨어지면, 5로 나눈다
2. x가 3으로 나누어 떨어지면, 3으로 나눈다
3. x가 2로 나누어 떨어지면, 2로 나눈다
4. x에서 1을 뺀다

+ 출력

연산을 하는 횟수의 최소값 출력

--------
### 코드 리뷰

+ 점화식

```
ai = min(ai-1 , ai/2, ai/3, ai/5 ) +1
```
두 수중에 더 작은 수를 구해야 하므로 min() 함수를 이용

+ DP 테이블 초기화

```python
d=[0]*30001
```

상향식 방식에서는 결과 저장용 리스트 'DP 테이블'을 사용

+ DP 진행 (상향식)

```python
for i in range(2,x+1):
  d[i]=d[i-1]+1
  if i%2==0:
    d[i]=min(d[i],d[i//2]+1)
  if i%3==0:
    d[i]=min(d[i],d[i//3]+1)
  if i%5==0:
    d[i]=min(d[i],d[i//5]+1)
```
-----------

## 개미 전사

+ 설명

식량창고의 최대 값을 구해야 한다. 단 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.

----

### 코드리뷰

+ 점화식
```
ai = max(ai-1, ai-2+ki)
```

+ 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화

```
d = [0] * 100
```

+ 다이나믹 프로그래밍 진행 (상향식)

```python
d[0]=array[0]
d[1]=max(array[0],array[1])
for i in range(2,n):
  d[i]=max(d[i-1],d[i-2]+array[i])
```

- d[1]= array[0] 과 array[1] 중 더 큰 값

- d[2]= d[1]과 d[0]+array[2] 중 더 큰 값

- d[3]= d[2]와 d[1]+array[3] 중 더 큰 값

--------

## 효율적인 화폐 구성

+ 설명

n가지 종류의 화폐를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 한다. 

+ 입력

첫 째 줄에 화폐 개수 n과 구할 돈 m , 두번 째 줄부턴 화폐의 가치가 입력

+ 출력

m원을 만들기 위한 최소한의 화폐 개수, 불가능할 때는 -1

----

### 코드 리뷰

+ 점화식

```
방법이 존재하는 경우 : ai=min(ai,ai-k +1)
방법이 존재하지 않는 경우 : ai=10,001
```

+ 다이나믹 프로그래밍 진행 (상향식)

```python
d[0]=0
for i in range(n):
  for j in range(array[i],m+1):
    if d[j-array[i]] != 10001:
      d[j]=min(d[j],d[j-array[i]]+1)
```
array의 첫번째 값부터 (화폐가치 첫번째 값) 구하고자하는 돈의 가치까지 반복한다.

반복문을 통해 d[j]에 현재 인덱스의 값과 현재 인덱스의 값에서 화폐가치를 빼고 1을더한 값중 작은 값을 저장해준다.
